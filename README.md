## 编写xobj的理由

语言之间，语法是不同的，库的接口是不同的，数据的组织结构是不同的，但是最基本的对象类型不过**数字和字符串**，最常用的结构不过**列表(动态数组)和字典(关联数组)**

xobj提供动态使用这些对象的能力，所有的对象通过Value包裹，Value内部持有不同类型对象的指针，每种对象都继承于Object

Value主要用于内存的自动管理：Value每次被构造，都将Object的引用+1，每次被析构都将Object的引用-1，直到引用为0，Object才会被真正释放

### 为什么不用Python

其实这和Python实现对象的方式是类似的，也可以使用Value包装一下，改变其引用计数

不过，Python需要附带一个很大的库，而且有太多不必须的功能，不够轻量级

### xobj的优势

* 类似于动态访问变量，像脚本一样使用C++
* 方便向其他语言的数据转换(Python、lua、java、js...)
* 方便向其他序列化语言的转换(JSON、MSGPACK...)
* 方便和底层数据打交道，同时方便和高级语言尤其是动态语言通信
* 体积小巧，便于作为静态库集成到程序里

## Features

* [x] 提供动态类型的容器(List, Dict)
* [x] 迭代器，可以使用迭代器遍历列表和字典
* [x] 基于引用计数的垃圾回收
* [ ] 提供向其它数据格式的转换(JSON, msgpack, ...)
  * [x] MSGPACK
* [ ] 提供其它语言对象的绑定(PyObject, lua table, ...)
  * [x] PyObject
* [x] 列表初始化，可以一次性构造不同元素类型的列表和字典，比如`auto l = L(1, "2", 3.0, true)`
* [x] 字符串内部化，意味着相同的单词只存在一份(在一个进程中)
